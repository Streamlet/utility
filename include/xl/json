// MIT License
//
// Copyright (c) 2022 Streamlet (streamlet@outlook.com)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <list>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <yyjson.h>
#if __cplusplus >= 201703L
#include <optional>
#include <string_view>

#endif
namespace xl {

namespace json {

enum WriteFlags {
  WRITE_FLAG_NONE = 0,
  WRITE_FLAG_PRETTY = 1 << 0,
  WRITE_FLAG_WRITE_NULL_VALUES = 1 << 1,
};

} // namespace json

template <typename T>
struct json_accessor {
  static bool read(T &ref, yyjson_val *json_value, yyjson_val *null_value) {
    return ref.json_read(json_value, null_value);
  }
  static bool will_write(const T &ref, unsigned int flags) {
    return true;
  }
  static yyjson_mut_val *write(const T &ref, yyjson_mut_doc *doc, unsigned int flags) {
    return ref.json_write(doc, flags);
  }
};

template <>
class json_accessor<bool> {
public:
  static bool read(bool &ref, yyjson_val *json_value, yyjson_val *null_value) {
    if (yyjson_is_null(json_value)) {
      ref = false;
      return true;
    }
    if (!yyjson_is_bool(json_value)) {
      return false;
    }
    ref = yyjson_get_bool(json_value);
    return true;
  }
  static bool will_write(const bool &ref, unsigned int flags) {
    return true;
  }
  static yyjson_mut_val *write(const bool &ref, yyjson_mut_doc *doc, unsigned int flags) {
    return yyjson_mut_bool(doc, ref);
  }
};

#define JSON_ACCESSOR_SINT(type, write_type)                                                                           \
  template <>                                                                                                          \
  class json_accessor<type> {                                                                                          \
  public:                                                                                                              \
    static bool read(type &ref, yyjson_val *json_value, yyjson_val *null_value) {                                      \
      if (yyjson_is_null(json_value)) {                                                                                \
        ref = 0;                                                                                                       \
        return true;                                                                                                   \
      }                                                                                                                \
      if (!yyjson_is_num(json_value)) {                                                                                \
        return false;                                                                                                  \
      }                                                                                                                \
      ref = (type)yyjson_get_num(json_value);                                                                          \
      return true;                                                                                                     \
    }                                                                                                                  \
    static bool will_write(const type &ref, unsigned int flags) {                                                      \
      return true;                                                                                                     \
    }                                                                                                                  \
    static yyjson_mut_val *write(const type &ref, yyjson_mut_doc *doc, unsigned int flags) {                           \
      return yyjson_mut_sint(doc, ref);                                                                                \
    }                                                                                                                  \
  }

#define JSON_ACCESSOR_UINT(type, write_type)                                                                           \
  template <>                                                                                                          \
  class json_accessor<type> {                                                                                          \
  public:                                                                                                              \
    static bool read(type &ref, yyjson_val *json_value, yyjson_val *null_value) {                                      \
      if (yyjson_is_null(json_value)) {                                                                                \
        ref = 0;                                                                                                       \
        return true;                                                                                                   \
      }                                                                                                                \
      if (!yyjson_is_num(json_value)) {                                                                                \
        return false;                                                                                                  \
      }                                                                                                                \
      ref = (type)yyjson_get_num(json_value);                                                                          \
      return true;                                                                                                     \
    }                                                                                                                  \
    static bool will_write(const type &ref, unsigned int flags) {                                                      \
      return true;                                                                                                     \
    }                                                                                                                  \
    static yyjson_mut_val *write(const type &ref, yyjson_mut_doc *doc, unsigned int flags) {                           \
      return yyjson_mut_uint(doc, ref);                                                                                \
    }                                                                                                                  \
  }

JSON_ACCESSOR_SINT(char, Int);
JSON_ACCESSOR_SINT(short, Int);
JSON_ACCESSOR_SINT(int, Int);
JSON_ACCESSOR_SINT(long, Int);
JSON_ACCESSOR_SINT(long long, Int64);

JSON_ACCESSOR_UINT(unsigned char, Uint);
JSON_ACCESSOR_UINT(unsigned short, Uint);
JSON_ACCESSOR_UINT(unsigned int, Uint);
JSON_ACCESSOR_UINT(unsigned long, Uint);
JSON_ACCESSOR_UINT(unsigned long long, Uint64);

template <>
class json_accessor<float> {
public:
  static bool read(float &ref, yyjson_val *json_value, yyjson_val *null_value) {
    if (yyjson_is_null(json_value)) {
      ref = 0;
      return true;
    }
    if (!yyjson_is_num(json_value)) {
      return false;
    }
    ref = (float)yyjson_get_num(json_value);
    return true;
  }
  static bool will_write(const float &ref, unsigned int flags) {
    return true;
  }
  static yyjson_mut_val *write(const float &ref, yyjson_mut_doc *doc, unsigned int flags) {
    return yyjson_mut_float(doc, ref);
  }
};

template <>
class json_accessor<double> {
public:
  static bool read(double &ref, yyjson_val *json_value, yyjson_val *null_value) {
    if (yyjson_is_null(json_value)) {
      ref = 0;
      return true;
    }
    if (!yyjson_is_num(json_value)) {
      return false;
    }
    ref = yyjson_get_num(json_value);
    return true;
  }
  static bool will_write(const double &ref, unsigned int flags) {
    return true;
  }
  static yyjson_mut_val *write(const double &ref, yyjson_mut_doc *doc, unsigned int flags) {
    return yyjson_mut_double(doc, ref);
  }
};

template <>
class json_accessor<std::string> {
public:
  static bool read(std::string &ref, yyjson_val *json_value, yyjson_val *null_value) {
    if (yyjson_is_null(json_value)) {
      ref = std::string();
      return true;
    }
    if (!yyjson_is_str(json_value)) {
      return false;
    }
    ref.assign(yyjson_get_str(json_value), yyjson_get_len(json_value));
    return true;
  }
  static bool will_write(const std::string &ref, unsigned int flags) {
    return true;
  }
  static yyjson_mut_val *write(const std::string &ref, yyjson_mut_doc *doc, unsigned int flags) {
    return yyjson_mut_strn(doc, ref.data(), ref.length());
  }
};

#if __cplusplus >= 201703L
template <>
class json_accessor<std::string_view> {
public:
  static bool read(std::string_view &ref, yyjson_val *json_value, yyjson_val *null_value) {
    if (yyjson_is_null(json_value)) {
      ref = std::string_view();
      return true;
    }
    if (!yyjson_is_str(json_value)) {
      return false;
    }
    ref = {yyjson_get_str(json_value), yyjson_get_len(json_value)};
    return true;
  }
  static bool will_write(const std::string_view &ref, unsigned int flags) {
    return true;
  }
  static yyjson_mut_val *write(const std::string_view &ref, yyjson_mut_doc *doc, unsigned int flags) {
    return yyjson_mut_strn(doc, ref.data(), ref.length());
  }
};
#endif

#define JSON_ACCESSOR_POINTER(pointer)                                                                                 \
  template <typename T>                                                                                                \
  class json_accessor<pointer<T>> {                                                                                    \
  public:                                                                                                              \
    static bool read(pointer<T> &ref, yyjson_val *json_value, yyjson_val *null_value) {                                \
      if (yyjson_is_null(json_value)) {                                                                                \
        ref.reset();                                                                                                   \
        return true;                                                                                                   \
      }                                                                                                                \
      ref = pointer<T>(new T());                                                                                       \
      return json_accessor<T>::read(*ref, json_value, null_value);                                                     \
    }                                                                                                                  \
    static bool will_write(const pointer<T> &ref, unsigned int flags) {                                                \
      return (flags & json::WRITE_FLAG_WRITE_NULL_VALUES) != 0 ||                                                      \
             (ref != nullptr && json_accessor<T>::will_write(*ref, flags));                                            \
    }                                                                                                                  \
    static yyjson_mut_val *write(const pointer<T> &ref, yyjson_mut_doc *doc, unsigned int flags) {                     \
      if (ref == nullptr) {                                                                                            \
        return yyjson_mut_null(doc);                                                                                   \
      } else {                                                                                                         \
        return json_accessor<T>::write(*ref, doc, flags);                                                              \
      }                                                                                                                \
    }                                                                                                                  \
  }

JSON_ACCESSOR_POINTER(std::unique_ptr);
JSON_ACCESSOR_POINTER(std::shared_ptr);

#if __cplusplus >= 201703L

template <typename T>
class json_accessor<std::optional<T>> {
public:
  static bool read(std::optional<T> &ref, yyjson_val *json_value, yyjson_val *null_value) {
    if (yyjson_is_null(json_value)) {
      ref.reset();
      return true;
    }
    ref = T();
    return json_accessor<T>::read(ref.value(), json_value, null_value);
  }
  static bool will_write(const std::optional<T> &ref, unsigned int flags) {
    return (flags & json::WRITE_FLAG_WRITE_NULL_VALUES) != 0 ||
           (ref.has_value() && json_accessor<T>::will_write(ref.value(), flags));
  }
  static yyjson_mut_val *write(const std::optional<T> &ref, yyjson_mut_doc *doc, unsigned int flags) {
    if (!ref.has_value()) {
      return yyjson_mut_null(doc);
    } else {
      return json_accessor<T>::write(ref.value(), doc, flags);
    }
  }
};

#endif

#define JSON_ACCESSOR_CONTAINER(container)                                                                             \
  template <typename T>                                                                                                \
  class json_accessor<container<T>> {                                                                                  \
  public:                                                                                                              \
    static bool read(container<T> &ref, yyjson_val *json_value, yyjson_val *null_value) {                              \
      if (yyjson_is_null(json_value)) {                                                                                \
        ref.clear();                                                                                                   \
        return true;                                                                                                   \
      }                                                                                                                \
      if (!yyjson_is_arr(json_value)) {                                                                                \
        return false;                                                                                                  \
      }                                                                                                                \
      yyjson_arr_iter iter;                                                                                            \
      yyjson_arr_iter_init(json_value, &iter);                                                                         \
      yyjson_val *val = nullptr;                                                                                       \
      while ((val = yyjson_arr_iter_next(&iter)) != nullptr) {                                                         \
        T t;                                                                                                           \
        if (!json_accessor<T>::read(t, val, null_value)) {                                                             \
          return false;                                                                                                \
        }                                                                                                              \
        ref.insert(ref.end(), std::move(t));                                                                           \
      }                                                                                                                \
      return true;                                                                                                     \
    }                                                                                                                  \
    static bool will_write(const container<T> &ref, unsigned int flags) {                                              \
      return true;                                                                                                     \
    }                                                                                                                  \
    static yyjson_mut_val *write(const container<T> &ref, yyjson_mut_doc *doc, unsigned int flags) {                   \
      yyjson_mut_val *arr = yyjson_mut_arr(doc);                                                                       \
      for (const T &item : ref) {                                                                                      \
        yyjson_mut_val *val = json_accessor<T>::write(item, doc, flags);                                               \
        yyjson_mut_arr_add_val(arr, val);                                                                              \
      }                                                                                                                \
      return arr;                                                                                                      \
    }                                                                                                                  \
  }

JSON_ACCESSOR_CONTAINER(std::vector);
JSON_ACCESSOR_CONTAINER(std::list);
JSON_ACCESSOR_CONTAINER(std::set);
JSON_ACCESSOR_CONTAINER(std::multiset);
JSON_ACCESSOR_CONTAINER(std::unordered_set);
JSON_ACCESSOR_CONTAINER(std::unordered_multiset);

#define JSON_ACCESSOR_MAP(map)                                                                                         \
  template <typename T>                                                                                                \
  class json_accessor<map<std::string, T>> {                                                                           \
  public:                                                                                                              \
    static bool read(map<std::string, T> &ref, yyjson_val *json_value, yyjson_val *null_value) {                       \
      if (yyjson_is_null(json_value)) {                                                                                \
        ref.clear();                                                                                                   \
        return true;                                                                                                   \
      }                                                                                                                \
      if (!yyjson_is_obj(json_value)) {                                                                                \
        return false;                                                                                                  \
      }                                                                                                                \
      yyjson_obj_iter iter;                                                                                            \
      yyjson_obj_iter_init(json_value, &iter);                                                                         \
      yyjson_val *key = nullptr, *val = nullptr;                                                                       \
      while ((key = yyjson_obj_iter_next(&iter)) != nullptr) {                                                         \
        val = yyjson_obj_iter_get_val(key);                                                                            \
        T t;                                                                                                           \
        if (!json_accessor<T>::read(t, val, null_value)) {                                                             \
          return false;                                                                                                \
        }                                                                                                              \
        const char *key_str = yyjson_get_str(key);                                                                     \
        if (key_str == nullptr) {                                                                                      \
          return false;                                                                                                \
        }                                                                                                              \
        ref.emplace(key_str, std::move(t));                                                                            \
      }                                                                                                                \
      return true;                                                                                                     \
    }                                                                                                                  \
    static bool will_write(const map<std::string, T> &ref, unsigned int flags) {                                       \
      return true;                                                                                                     \
    }                                                                                                                  \
    static yyjson_mut_val *write(const map<std::string, T> &ref, yyjson_mut_doc *doc, unsigned int flags) {            \
      yyjson_mut_val *obj = yyjson_mut_obj(doc);                                                                       \
      for (const auto &item : ref) {                                                                                   \
        if (!json_accessor<T>::will_write(item.second, flags)) {                                                       \
          continue;                                                                                                    \
        }                                                                                                              \
        yyjson_mut_val *key = yyjson_mut_str(doc, item.first.c_str());                                                 \
        yyjson_mut_val *val = json_accessor<T>::write(item.second, doc, flags);                                        \
        yyjson_mut_obj_add(obj, key, val);                                                                             \
      }                                                                                                                \
      return obj;                                                                                                      \
    }                                                                                                                  \
  }

JSON_ACCESSOR_MAP(std::map);
JSON_ACCESSOR_MAP(std::multimap);
JSON_ACCESSOR_MAP(std::unordered_map);
JSON_ACCESSOR_MAP(std::unordered_multimap);

} // namespace xl

#define XL_JSON_BEGIN(struct_type)                                                                                     \
  struct struct_type {                                                                                                 \
  private:                                                                                                             \
    template <typename T, size_t Index>                                                                                \
    struct field_json_accessor_t;                                                                                      \
    typedef struct_type Type;                                                                                          \
    static const size_t SEQUENCE = __COUNTER__;                                                                        \
                                                                                                                       \
  public:                                                                                                              \
    template <size_t Index>                                                                                            \
    using field_json_accessor = field_json_accessor_t<struct_type, Index>;

#define XL_JSON_MEMBER(field_type, field_name)                                                                         \
public:                                                                                                                \
  field_type field_name;                                                                                               \
                                                                                                                       \
private:                                                                                                               \
  template <typename T>                                                                                                \
  struct field_json_accessor_t<T, __COUNTER__ - SEQUENCE - 1> {                                                        \
    static bool read(Type &ref, yyjson_val *json_value, yyjson_val *null_value) {                                      \
      yyjson_val *val = nullptr;                                                                                       \
      if (yyjson_is_obj(json_value) && (val = yyjson_obj_get(json_value, #field_name)) != nullptr) {                  \
        return ::xl::json_accessor<field_type>::read(ref.field_name, val, null_value);                                 \
      } else {                                                                                                         \
        return ::xl::json_accessor<field_type>::read(ref.field_name, null_value, null_value);                          \
      }                                                                                                                \
    }                                                                                                                  \
    static bool will_write(const Type &ref, unsigned int flags) {                                                      \
      return ::xl::json_accessor<field_type>::will_write(ref.field_name, flags);                                       \
    }                                                                                                                  \
    static void write(const Type &ref, yyjson_mut_doc *doc, yyjson_mut_val *parent, unsigned int flags) {              \
      if (!will_write(ref, flags)) {                                                                                   \
        return;                                                                                                        \
      }                                                                                                                \
      yyjson_mut_val *key = yyjson_mut_str(doc, #field_name);                                                          \
      yyjson_mut_val *val = ::xl::json_accessor<field_type>::write(ref.field_name, doc, flags);                        \
      yyjson_mut_obj_add(parent, key, val);                                                                            \
    }                                                                                                                  \
  };

#define XL_JSON_END()                                                                                                  \
private:                                                                                                               \
  static const size_t FIELDS = __COUNTER__ - SEQUENCE - 1;                                                             \
  template <size_t Begin, size_t End>                                                                                  \
  struct fields_json_accessor_walker {                                                                                 \
    static bool read(Type &ref, yyjson_val *json_value, yyjson_val *null_value) {                                      \
      if (!yyjson_is_obj(json_value) && !yyjson_is_null(json_value)) {                                                 \
        return false;                                                                                                  \
      }                                                                                                                \
      if (!field_json_accessor<Begin>::read(ref, json_value, null_value)) {                                            \
        return false;                                                                                                  \
      }                                                                                                                \
      if (!fields_json_accessor_walker<Begin + 1, End>::read(ref, json_value, null_value)) {                           \
        return false;                                                                                                  \
      }                                                                                                                \
      return true;                                                                                                     \
    }                                                                                                                  \
    static bool will_write(const Type &ref, unsigned int flags) {                                                      \
      if (field_json_accessor<Begin>::will_write(ref, flags)) {                                                        \
        return true;                                                                                                   \
      }                                                                                                                \
      return fields_json_accessor_walker<Begin + 1, End>::will_write(ref, flags);                                      \
    }                                                                                                                  \
    static void write(const Type &ref, yyjson_mut_doc *doc, yyjson_mut_val *parent, unsigned int flags) {              \
      field_json_accessor<Begin>::write(ref, doc, parent, flags);                                                      \
      fields_json_accessor_walker<Begin + 1, End>::write(ref, doc, parent, flags);                                     \
    }                                                                                                                  \
  };                                                                                                                   \
  template <size_t Index>                                                                                              \
  struct fields_json_accessor_walker<Index, Index> {                                                                   \
    static bool read(Type &ref, yyjson_val *json_value, yyjson_val *null_value) {                                      \
      return true;                                                                                                     \
    }                                                                                                                  \
    static bool will_write(const Type &ref, unsigned int flags) {                                                      \
      return false;                                                                                                    \
    }                                                                                                                  \
    static void write(const Type &ref, yyjson_mut_doc *doc, yyjson_mut_val *parent, unsigned int flags) {              \
    }                                                                                                                  \
  };                                                                                                                   \
                                                                                                                       \
private:                                                                                                               \
  friend ::xl::json_accessor<Type>;                                                                                    \
  bool json_read(yyjson_val *json_value, yyjson_val *null_value) {                                                     \
    bool r = fields_json_accessor_walker<0, FIELDS>::read(*this, json_value, null_value);                              \
    return r;                                                                                                          \
  }                                                                                                                    \
  bool json_will_write(unsigned int flags) const {                                                                     \
    return fields_json_accessor_walker<0, FIELDS>::will_write(*this, flags);                                           \
  }                                                                                                                    \
  yyjson_mut_val *json_write(yyjson_mut_doc *doc, unsigned int flags) const {                                          \
    yyjson_mut_val *obj = yyjson_mut_obj(doc);                                                                         \
    fields_json_accessor_walker<0, FIELDS>::write(*this, doc, obj, flags);                                             \
    return obj;                                                                                                        \
  }                                                                                                                    \
                                                                                                                       \
public:                                                                                                                \
  bool json_parse(const char *json_string) {                                                                           \
    yyjson_doc *doc =                                                                                                  \
        yyjson_read(json_string, strlen(json_string), YYJSON_READ_ALLOW_COMMENTS | YYJSON_READ_ALLOW_TRAILING_COMMAS); \
    if (doc == nullptr) {                                                                                              \
      return false;                                                                                                    \
    }                                                                                                                  \
    yyjson_val *root = yyjson_doc_get_root(doc);                                                                       \
    bool r = false;                                                                                                    \
    if (root != nullptr) {                                                                                             \
      yyjson_doc *null_doc = yyjson_read("null", 4, 0);                                                                \
      yyjson_val *null_value = yyjson_doc_get_root(null_doc);                                                          \
      r = json_read(root, null_value);                                                                                 \
      yyjson_doc_free(null_doc);                                                                                       \
    }                                                                                                                  \
    yyjson_doc_free(doc);                                                                                              \
    return r;                                                                                                          \
  }                                                                                                                    \
  std::string json_dump(unsigned int flags = ::xl::json::WRITE_FLAG_NONE) {                                            \
    int yyjson_flags = 0;                                                                                              \
    if ((flags & ::xl::json::WRITE_FLAG_PRETTY) != 0) {                                                                \
      flags &= ~::xl::json::WRITE_FLAG_PRETTY;                                                                         \
      yyjson_flags |= YYJSON_WRITE_PRETTY;                                                                             \
    }                                                                                                                  \
    yyjson_mut_doc *doc = yyjson_mut_doc_new(NULL);                                                                    \
    yyjson_mut_val *root = json_write(doc, flags);                                                                     \
    yyjson_mut_doc_set_root(doc, root);                                                                                \
    size_t len = 0;                                                                                                    \
    const char *json = yyjson_mut_write(doc, yyjson_flags, &len);                                                      \
    std::string json_string(json, len);                                                                                \
    free((void *)json);                                                                                                \
    yyjson_mut_doc_free(doc);                                                                                          \
    return std::move(json_string);                                                                                     \
  }                                                                                                                    \
  }                                                                                                                    \
  ;
